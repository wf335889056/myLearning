/*
 * react性能优化
 *
 *  1. 减少渲染的节点/降低渲染的计算量
 *   减少节点渲染的数量或者降低渲染的计算量可以显著的提高组件渲染性能。
 *    具体方案
 *    不要在render函数中做过多的计算操作, 应该是一个纯渲染的函数
 *    减少不必要的嵌套, 可以利用小组件的方式  
 *    选择合适样式渲染方式 css类 > 对象声明样式 > 行内样式
 * 
 *  2. 避免重渲染
 *   保证组件纯粹性。即控制组件的副作用，如果组件有副作用则无法安全地缓存渲染结果
 *   通过shouldComponentUpdate生命周期函数来比对 state 和 props, 确定是否要重新渲染。对于函数组件可以使用React.memo包装
 *    具体方案
 *    简化props, 可提高组件缓存的命中率
 *    避免使用箭头函数形式的事件处理器
 *    不可变数据可以让状态变得可预测，也让 shouldComponentUpdate '浅比较'变得更可靠和高效. 
 *    不是所有状态都应该放在组件的 state 中. 例如缓存数据。
 *    按照我的原则是：如果需要组件响应它的变动, 或者需要渲染到视图中的数据才应该放到 state 中。这样可以避免不必要的数据变动导致组件重新渲染.
 *    
 *  3. 精细化渲染
 *    所谓精细化渲染指的是只有一个数据来源导致组件重新渲染, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 
 *    其他状态变化不应该影响组件 A。
 *    具体方案
 *    划分更细的小组件, 每个小组件都有一个单一的职责复制组件是否需要发生变化
 *    
 */

 /*
  * fiber调度
  * 为什么出现
  * 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，
  * 导致一些动画或高频操作出现卡顿和掉帧的情况。  
  * 而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，
  * 而这个过程最大的问题就是无法 暂停和恢复。
  * 解决方案
  * 解决同步阻塞的方法，通常有两种: 异步 与 任务分割。而 React Fiber 便是为了实现任务分割而诞生的。
  *
  * 链表树遍历算法: 通过 节点保存与映射，便能够随时地进行 停止和重启，这样便能达到实现任务分割的基本前提；
  * 通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。
  *  1、首先通过不断遍历子节点，到树末尾；
  *  2、开始通过 sibling 遍历兄弟节点；
  *  3、return 返回父节点，继续执行2；
  *  4、直到 root 节点后，跳出遍历；
  * 
  * 任务分割调度算法: 主要是 将原先同步更新渲染的任务分割成一个个独立的小任务单位，
  * 根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。
  * reconciliation 阶段: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。
  * Commit 阶段: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。
  * 否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。
  * 优先级策略: 文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务
  */ 