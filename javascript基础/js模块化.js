/*
 * 模块化的好处:
 * 避免命名冲突(减少命名空间污染)
 * 更好的分离, 按需加载
 * 更高复用性
 * 高可维护性
 * 
 */

/*
 * 函数
 * 实现模块化的方式使用函数进行封装。将不同功能的代码实现封装到不同的函数中。
 * 通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。
 * 
 * 缺陷: 容易发生命名冲突或者数据的不安全性
 * 
 */

/*
 * 立即执行函数(函数自执行)
 * 立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。
 * 通过函数作用域解决了命名冲突、污染全局作用域的问题 。
 * 
 */

/*
 * CommonJS
 * CommonJS 的规范主要用在 Node.js 中，为模块提供了四个接口：module、exports、require、global。
 * ommonJS 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。
 * 
 * CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
 * 特点
 * 1. 所有代码都运行在模块作用域，不会污染全局作用域。
 * 2. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，
 * 以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
 * 3. 模块加载的顺序，按照其在代码中出现的顺序。
 * 
 */ 

// AMD 默认推荐的是
define(['./a', './b'], function(a, b) {  
  // 依赖必须一开始就写好    
  a.doSomething()    // 此处略去 100 行   
  b.doSomething()    
   // ...
})

/*
 * AMD
 * AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
 * 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。
 * 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
 *  
 * 推崇依赖前置、提前执行
 * 
 */ 

// CMD
define(function(require, exports, module) {  
  var a = require('./a')   
  a.doSomething()   // 此处略去 100 行   
  var b = require('./b') // 依赖可以就近书写   
  b.doSomething()   
  // ... 
})

/*
 * CMD
 * CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
 * 主要在浏览器中运行，当然也可以在Node.js中运行。
 * 
 * 推崇依赖就近、延迟执行
 * 
 */ 



/*
 * UMD
 * 通用模块定义模式，该模式主要用来解决CommonJS模式和AMD模式代码不能通用的问题，并同时还支持老式的全局变量规范。
 * 
 * 1. 判断define为函数，并且是否存在define.amd，来判断是否为AMD规范,
 * 2. 判断module是否为一个对象，并且是否存在module.exports来判断是否为CommonJS规范
 * 3. 如果以上两种都没有，设定为原始的代码规范。
 * 
 */ 

/*
 * es6 module
 * ES6 实现的模块非常简单，用于浏览器和服务器端。mport命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .
 * 主要有两个命令组成：export和import:
 * 
 * export命令用于规定模块的对外接口。
 * import命令引入其他模块的功能。
 * 
 * 1. 它因为是标准，所以未来很多浏览器会支持，可以很方便的在浏览器中使用。(浏览器默认加载不能省略.js)
 * 2. 它同时兼容在node环境下运行。
 * 3. 模块的导入导出，通过import和export来确定。 可以和Commonjs模块混合使用。
 * 4. ES modules 输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝
 * 5. ES modules 模块编译时执行，而 CommonJS 模块总是在运行时加载
 * 
 */ 

/*
 * ES6 模块与 CommonJS 模块的区别
 * 1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
 *  所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。
 *  ES6 模块是动态引用，不缓存值，模块内外是绑定的，而且是只读引用，不能修改值。
 *  ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 import ，就会生成一个只读引用，
 *  当真正用到模块里边的值的时候，就会去模块内部去取。
 * 2. CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。
 *  运行时加载：CommonJS 模块就是对象；是先加载整个模块，生成一个对象，
 *  然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
 *  编译时加载： ES6模块不是对象，而是通过 export 命令「显式指定输出的代码」。
 *  import 时采用静态命令的形式，即在import指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 
 * 
 */ 

/*
 * CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，
 * 因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。
 * 
 * AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。
 * 不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。
 * 
 * CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。
 * 不过，依赖 SPM 打包，模块的加载逻辑偏重。
 * 
 * ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，
 * 完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
 * 
 */ 